
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title> | JXCUSO4的博客</title>
    <meta name="author" content="JXCUSO4" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/star.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>JXCUSO4的博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;JXCUSO4的博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1></h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/29
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>title: &gt;-<br>  暑期文献阅读六   Turning Dust into Gold拓展一    SELF-REFINE: Iterative Refinement with Self-Feedback</p>
<p>date: 2024-08-2 15:12:4</p>
<p>tags:<br>secret: “123456”<br>description: |<br>    Normal _Italic_ <strong>Strong</strong></p>
<h1 id="SELF-REFINE-Iterative-Refinement-with-Self-Feedback"><a href="#SELF-REFINE-Iterative-Refinement-with-Self-Feedback" class="headerlink" title="SELF-REFINE: Iterative Refinement with Self-Feedback"></a>SELF-REFINE: Iterative Refinement with Self-Feedback</h1><h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>尽管大语言模型（LLMs）能够生成连贯的输出，但它们在处理复杂需求时往往显得不足。这主要包括具有多重目标的任务，如对话响应生成，或目标难以定义的任务，如提高程序的可读性。在这些情况下，现代LLMs可能会生成一个可理解的初始输出，但可能需要进一步的迭代改进，即将候选输出映射到改进后的输出，以确保达到预期的质量。迭代改进通常涉及训练一个依赖于特定领域数据的改进模型（例如，Reid和Neubig，2022；Schick等，2022a；Welleck等，2022）。其他依赖外部监督或奖励模型的方法需要大量的训练集或昂贵的人工注释（Madaan等，2021；Ouyang等，2022），这可能并不总是可行。</p>
<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><p>我们提出了SELF-REFINE：一种迭代自我改进算法，交替进行两个生成步骤——反馈（FEEDBACK）和改进（REFINE）。这些步骤协同工作，生成高质量的输出。给定模型M生成的初始输出，我们将其反馈给相同的模型M以获取反馈。然后，将反馈传递回相同的模型以改进之前生成的草稿。这个过程可以重复指定的次数，或者直到M确定不再需要进一步改进。</p>
<p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%20(2" alt="image-20240727164042822">/image-20240727164042822.png)</p>
<h1 id="how"><a href="#how" class="headerlink" title="how"></a>how</h1><h1 id="Iterative-Refinement-with-SELF-REFINE"><a href="#Iterative-Refinement-with-SELF-REFINE" class="headerlink" title="Iterative Refinement with SELF-REFINE"></a>Iterative Refinement with SELF-REFINE</h1><p>SELF-REFINE依赖于合适的语言模型和三个提示（用于初始生成、反馈和改进）</p>
<p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%20(2" alt="image-20240727173925381">/image-20240727173925381.png)</p>
<h2 id="初始生成-Initial-generation"><a href="#初始生成-Initial-generation" class="headerlink" title="初始生成 Initial generation"></a>初始生成 Initial generation</h2><p>给定输入 x、提示 $p_{\text{gen}}$ 和模型M，SELF-REFINE 生成初始输出 $y_0$：</p>
<script type="math/tex; mode=display">
y_0 = M(p_{\text{gen}} \| x)</script><p>例如，在图(d)中，模型为给定的输入生成了功能上正确的代码。这里，$p_{\text{gen}}$是任务特定的少量示例提示（或指令）用于初始生成，$| $ 表示连接操作。少量示例提示包含任务的输入-输出对$ ⟨x^{(k)}, y^{(k)}⟩$。</p>
<h2 id="反馈-FEEDBACK"><a href="#反馈-FEEDBACK" class="headerlink" title="反馈 FEEDBACK"></a>反馈 FEEDBACK</h2><p>接下来，SELF-REFINE 使用相同的模型 M 对其输出提供反馈 $f_{\text{bt}}$，给定一个用于生成反馈的任务特定提示 $p_{\text{fb}}$：</p>
<p>$f_{\text{bt}} = M(p_{\text{fb}} | x | y_t)$      等式3</p>
<p>直观上，反馈可能涉及输出的多个方面。例如，在代码优化中，反馈可能涉及代码的效率、可读性和整体质量。这里，提示 $p_{\text{fb}}$提供了以输入-输出-反馈三元组 $⟨x^{(k)}, y^{(k)}, fb^{(k)}⟩ $形式存在的反馈示例。我们通过$fb^{(k)}$ 提示模型编写可操作和具体的反馈。所谓“可操作”，意味着反馈应包含一个可能改进输出的具体行动。所谓“具体”，意味着反馈应识别输出中需要更改的具体短语。例如，图2(e)中的反馈是“这个代码很慢，因为它使用了一个暴力的for循环。更好的方法是使用公式…(n(n+1))/2”。这个反馈是可操作的，因为它建议了“使用公式…”的行动。反馈是具体的，因为它提到了“for循环”。</p>
<h2 id="改进-REFINE"><a href="#改进-REFINE" class="headerlink" title="改进 REFINE"></a>改进 REFINE</h2><p>接下来，SELF-REFINE 使用模型 M 来根据自身的反馈改进其最近的输出：$y_{t+1} = M(p_{\text{refine}} | x | y_t | f_{bt})$ 例如，在图2(f)中，给定初始输出和生成的反馈，模型生成了一个更短且运行速度更快的重新实现。提示 $p_{\text{refine}}$提供了基于反馈改进输出的示例，以输入-输出-反馈-改进四元组$ ⟨x^{(k)}, y^{(k)}_t, fb^{(k)}_t, y^{(k)}_{t+1}⟩ $的形式存在。</p>
<h2 id="迭代-SELF-REFINE"><a href="#迭代-SELF-REFINE" class="headerlink" title="迭代 SELF-REFINE"></a>迭代 SELF-REFINE</h2><p>SELF-REFINE 在反馈 (FEEDBACK) 和改进 (REFINE) 步骤之间交替进行，直到满足停止条件。停止条件$\text{stop}(f_{\text{bt}}, t)$ 要么在指定的时间步 ttt 停止，要么从反馈中提取停止指示器（例如，标量停止得分）。</p>
<p>为了告知模型之前的迭代过程，我们通过将之前的反馈和输出附加到提示中来保留它们的历史记录。直观上，这允许模型从过去的错误中学习并避免重复这些错误。更确切地说，等式 (3) 实际上是实现为： $y_{t+1} = M(p_{\text{refine}} | x | y_0 | fb_0 | \ldots | y_t | f_{bt})$</p>
<p>最后，我们使用最后一次改进的 $y_t$ 作为 SELF-REFINE 的输出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%20(2" alt="image-20240727175911646">/image-20240727175911646.png)</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="baselines"><a href="#baselines" class="headerlink" title="baselines"></a>baselines</h2><p>因此，我们将SELF-REFINE与相同的基础LLM（但没有反馈-改进迭代）进行比较。我们在所有任务中使用了三个主要的强大基础LLM：GPT-3.5（text-davinci-003）、CHATGPT（gpt-3.5-turbo）和GPT-4（OpenAI，2023）。对于基于代码的任务，我们还尝试了CODEX（code-davinci-002）。在所有任务中，GPT-3.5或GPT-4是之前的最新技术水平。我们使用了前人工作的相同提示（如代码优化和数学推理）；否则，我们按照<strong>附录V</strong>的详细说明创建提示。我们使用温度为0.7生成样本</p>
<h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><p>我们报告了三种类型的评估指标：</p>
<ul>
<li><strong>任务特定指标</strong>：当可用时，我们使用来自先前工作的自动化指标（如数学推理的%解决率；代码优化的%优化程序）。</li>
<li><strong>GPT-4偏好</strong>：除了人类偏好，我们还使用GPT-4作为人类偏好的代理，遵循先前的工作（Fu等，2023；Chiang等，2023；Geng等，2023；Sun等，2023），发现与人类偏好的高相关性（情感反转为82%，首字母缩略词生成为68%，对话响应生成为71%）。对于代码可读性改进，我们提示GPT-4计算上下文中适当命名的变量的比例（如x = [] → input_buffer = []）。附录F提供了更多细节。对于受限生成，我们结合自动评估以量化概念覆盖率，并使用GPT-4偏好来确保生成句子的常识正确性。只有在常识推理中保持有效并在概念覆盖率方面表现更好的句子才被认为是优胜者。</li>
<li><strong>人类评估</strong>：在对话响应生成、代码可读性改进、情感反转和首字母缩略词生成任务中，我们还对输出的子集进行了盲A/B人类评估，以选择偏好的输出。附录C提供了更多细节。</li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%20(2" alt="image-20240728145652536">/image-20240728145652536.png)</p>
<p>在基础LLM规模上的改进是一致的。总体而言，GPT-4+SELF-REFINE在所有任务上都优于GPT-3.5+SELF-REFINE和CHATGPT+SELF-REFINE，即使在一些GPT-4初始基础结果低于GPT-3.5或CHATGPT的任务中也是如此。因此，我们认为SELF-REFINE允许更强大的模型（如GPT-4）释放其全部潜力，即使在标准的单次输出生成中未能表现出这种潜力。</p>
<h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%20(2" alt="image-20240728150146552">/image-20240728150146552.png)</p>
<p>为了量化其影响，我们比较了使用具体、可操作反馈的SELF-REFINE与两种变体：一种使用通用反馈，另一种没有反馈（模型可能仍会迭代改进其生成，但不会明确提供反馈）。</p>
<p>例如，在代码优化任务中：可操作的反馈，如“避免在for循环中重复计算”，指出了问题并建议了明确的改进。通用反馈，如“提高代码效率”，则缺乏这种精确性和方向性。表2显示了反馈的显著影响。</p>
<h2 id="How-important-are-the-multiple-iterations-of-FEEDBACK-REFINE"><a href="#How-important-are-the-multiple-iterations-of-FEEDBACK-REFINE" class="headerlink" title="How important are the multiple iterations of FEEDBACK-REFINE?"></a>How important are the multiple iterations of FEEDBACK-REFINE?</h2><p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%20(2" alt="image-20240728150452000">/image-20240728150452000.png)</p>
<p> C. Opt.（代码优化）、S. Rev.（情感反转）、C. Gen.（受限生成）</p>
<p>SELF-REFINE通过迭代反馈和改进显著提升了多项任务的性能，尤其是在早期迭代中表现出显著改进，随着迭代次数的增加，边际收益有所减小，但整体趋势向好。</p>
<h2 id="Can-we-just-generate-multiple-outputs-instead-of-refining"><a href="#Can-we-just-generate-multiple-outputs-instead-of-refining" class="headerlink" title="Can we just generate multiple outputs instead of refining?"></a>Can we just generate multiple outputs instead of refining?</h2><p><img src="C:/Users/Jerry/AppData/Roaming/Typora/typora-user-images/image-20240728150711987.png" alt="image-20240728150711987"></p>
<p><strong>生成多个输出 vs. 迭代改进</strong></p>
<p>我们比较了SELF-REFINE和CHATGPT（生成k = 4个样本但没有反馈和改进）的性能。然后，我们将SELF-REFINE的性能与这k个初始输出进行了1对k的评估。换句话说，我们评估了SELF-REFINE是否能胜过所有k个初始输出。</p>
<h2 id="Does-SELF-REFINE-works-in-an-instruction-only-setup"><a href="#Does-SELF-REFINE-works-in-an-instruction-only-setup" class="headerlink" title="Does SELF-REFINE works in an instruction only setup?"></a>Does SELF-REFINE works in an instruction only setup?</h2><p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%20(2" alt="image-20240728152634353">/image-20240728152634353.png)</p>
<p>SELF-REFINE在仅使用指令的设置下依然具有很高的有效性，尤其在需要广泛指令工程的情况下可以显著提升模型性能。</p>
<h2 id="Does-SELF-REFINE-work-with-weaker-models"><a href="#Does-SELF-REFINE-work-with-weaker-models" class="headerlink" title="Does SELF-REFINE work with weaker models?"></a>Does SELF-REFINE work with weaker models?</h2><p>较弱的模型在以下方面存在问题：</p>
<ol>
<li><strong>反馈生成</strong>：难以生成一致且有用的反馈。</li>
<li><strong>改进遵从性</strong>：即使提供明确的反馈提示，模型也无法有效遵循进行改进。</li>
<li><strong>输出质量</strong>：改进后的输出质量不稳定，常出现重复或无关对话。</li>
</ol>
<p><img src="F:/%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4/%E5%8D%9A%E5%AE%A2/source/_posts/SELF-REFINE%20Iterative%20Refinement%20with%20Self-Feedback/image-20240801163943363.png" alt="image-20240801163943363"></p>
<p>实际上他的feedback就是从这十个方向评分，感觉有点水</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 JXCUSO4的博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;JXCUSO4
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
